{
	"name": "lru_map",
	"versions": {
		"0.3.3": {
			"name": "lru_map",
			"description": "Finite key-value map using the Least Recently Used (LRU) algorithm where the most recently used objects are keept in the map while less recently used items are evicted to make room for new ones.",
			"version": "0.3.3",
			"author": {
				"name": "Rasmus Andersson",
				"email": "me@rsms.me"
			},
			"homepage": "https://github.com/rsms/js-lru#readme",
			"repository": {
				"type": "git",
				"url": "git+https://github.com/rsms/js-lru.git"
			},
			"bugs": {
				"url": "https://github.com/rsms/js-lru/issues"
			},
			"main": "lru.js",
			"dist": {
				"tarball": "https://repo.dev.wixpress.com/artifactory/api/npm/npm-repos/lru_map/-/lru_map-0.3.3.tgz",
				"shasum": "b5c8351b9464cbd750335a79650a0ec0e56118dd"
			},
			"devDependencies": {
				"typescript": "^2.0.10"
			},
			"keywords": [
				"cache",
				"lru",
				"buffer",
				"map"
			],
			"license": "MIT",
			"maintainers": [
				{
					"name": "rsms",
					"email": "rasmus@notion.se"
				}
			],
			"directories": {},
			"scripts": {
				"test": "node test.js && echo 'Verifying TypeScript definition...' && tsc --noEmit",
				"prepublish": "npm test",
				"benchmark": "node --expose-gc benchmark.js"
			},
			"_from": ".",
			"_npmVersion": "3.10.10",
			"_npmUser": {
				"name": "rsms",
				"email": "rasmus@notion.se"
			},
			"_id": "lru_map@0.3.3",
			"gitHead": "427fd5dde56ac1cf5ba14511d4a4daa47bdb21ce",
			"typings": "lru.d.ts",
			"_npmOperationalInternal": {
				"host": "packages-12-west.internal.npmjs.com",
				"tmp": "tmp/lru_map-0.3.3.tgz_1489258818355_0.34295228752307594"
			},
			"_shasum": "b5c8351b9464cbd750335a79650a0ec0e56118dd",
			"_nodeVersion": "7.3.0"
		},
		"0.3.1": {
			"name": "lru_map",
			"description": "Finite key-value map using the Least Recently Used (LRU) algorithm where the most recently used objects are keept in the map while less recently used items are evicted to make room for new ones.",
			"version": "0.3.1",
			"author": {
				"name": "Rasmus Andersson",
				"email": "me@rsms.me"
			},
			"homepage": "https://github.com/rsms/js-lru#readme",
			"repository": {
				"type": "git",
				"url": "git+https://github.com/rsms/js-lru.git"
			},
			"bugs": {
				"url": "https://github.com/rsms/js-lru/issues"
			},
			"main": "lru.js",
			"dist": {
				"tarball": "https://repo.dev.wixpress.com/artifactory/api/npm/npm-repos/lru_map/-/lru_map-0.3.1.tgz",
				"shasum": "b96dcf6ffd06df30000fd63290a5b706a50d89e0"
			},
			"keywords": [
				"cache",
				"lru",
				"buffer",
				"map"
			],
			"license": "MIT",
			"maintainers": [
				{
					"name": "rsms",
					"email": "rasmus@notion.se"
				}
			],
			"directories": {},
			"scripts": {
				"test": "node test.js && echo 'Verifying TypeScript definition...' && tsc --noEmit",
				"prepublish": "npm test",
				"benchmark": "node --expose-gc benchmark.js"
			},
			"_from": ".",
			"_npmVersion": "3.10.3",
			"_npmUser": {
				"name": "rsms",
				"email": "rasmus@notion.se"
			},
			"_id": "lru_map@0.3.1",
			"gitHead": "29dbde97580bdaded774b9ca77be93fc195cad8e",
			"typings": "lru.d.ts",
			"_npmOperationalInternal": {
				"host": "packages-12-west.internal.npmjs.com",
				"tmp": "tmp/lru_map-0.3.1.tgz_1479266289844_0.6622927004937083"
			},
			"_shasum": "b96dcf6ffd06df30000fd63290a5b706a50d89e0",
			"_nodeVersion": "6.4.0"
		},
		"0.3.2": {
			"name": "lru_map",
			"description": "Finite key-value map using the Least Recently Used (LRU) algorithm where the most recently used objects are keept in the map while less recently used items are evicted to make room for new ones.",
			"version": "0.3.2",
			"author": {
				"name": "Rasmus Andersson",
				"email": "me@rsms.me"
			},
			"homepage": "https://github.com/rsms/js-lru#readme",
			"repository": {
				"type": "git",
				"url": "git+https://github.com/rsms/js-lru.git"
			},
			"bugs": {
				"url": "https://github.com/rsms/js-lru/issues"
			},
			"main": "lru.js",
			"dist": {
				"tarball": "https://repo.dev.wixpress.com/artifactory/api/npm/npm-repos/lru_map/-/lru_map-0.3.2.tgz",
				"shasum": "9b34996d5e77845647776ee670edfb8857e24368"
			},
			"keywords": [
				"cache",
				"lru",
				"buffer",
				"map"
			],
			"license": "MIT",
			"maintainers": [
				{
					"name": "rsms",
					"email": "rasmus@notion.se"
				}
			],
			"directories": {},
			"scripts": {
				"test": "node test.js && echo 'Verifying TypeScript definition...' && tsc --noEmit",
				"prepublish": "npm test",
				"benchmark": "node --expose-gc benchmark.js"
			},
			"_from": ".",
			"_npmVersion": "3.10.3",
			"_npmUser": {
				"name": "rsms",
				"email": "rasmus@notion.se"
			},
			"_id": "lru_map@0.3.2",
			"gitHead": "e43c5a428ebb6d3b4edf95a47b2a4fa7d98cdcf7",
			"typings": "lru.d.ts",
			"_npmOperationalInternal": {
				"host": "packages-18-east.internal.npmjs.com",
				"tmp": "tmp/lru_map-0.3.2.tgz_1479266883951_0.7229913782794029"
			},
			"_shasum": "9b34996d5e77845647776ee670edfb8857e24368",
			"_nodeVersion": "6.4.0"
		},
		"0.3.0": {
			"name": "lru_map",
			"description": "Finite key-value map using the Least Recently Used (LRU) algorithm where the most recently used objects are keept in the map while less recently used items are evicted to make room for new ones.",
			"version": "0.3.0",
			"author": {
				"name": "Rasmus Andersson",
				"email": "me@rsms.me"
			},
			"homepage": "https://github.com/rsms/js-lru#readme",
			"repository": {
				"type": "git",
				"url": "git+https://github.com/rsms/js-lru.git"
			},
			"bugs": {
				"url": "https://github.com/rsms/js-lru/issues"
			},
			"main": "lru.js",
			"dist": {
				"tarball": "https://repo.dev.wixpress.com/artifactory/api/npm/npm-repos/lru_map/-/lru_map-0.3.0.tgz",
				"shasum": "e73bb0220706c64e22c83c9982283f8fb9799236"
			},
			"keywords": [
				"cache",
				"lru",
				"buffer",
				"map"
			],
			"license": "MIT",
			"maintainers": [
				{
					"name": "rsms",
					"email": "rasmus@notion.se"
				}
			],
			"directories": {},
			"scripts": {
				"test": "node test.js && echo 'Verifying TypeScript definition...' && tsc --noEmit",
				"prepublish": "npm test",
				"benchmark": "node --expose-gc benchmark.js"
			},
			"_from": ".",
			"_npmVersion": "3.10.3",
			"_npmUser": {
				"name": "rsms",
				"email": "rasmus@notion.se"
			},
			"_id": "lru_map@0.3.0",
			"gitHead": "34436a7f724c00859537eb6d5633b727aa7a7d9d",
			"typings": "lru.d.ts",
			"_npmOperationalInternal": {
				"host": "packages-12-west.internal.npmjs.com",
				"tmp": "tmp/lru_map-0.3.0.tgz_1479265079418_0.49912197864614427"
			},
			"_shasum": "e73bb0220706c64e22c83c9982283f8fb9799236",
			"_nodeVersion": "6.4.0"
		}
	},
	"time": {
		"0.3.3": "2017-03-11T19:00:18.614Z",
		"0.3.1": "2016-11-16T03:18:10.071Z",
		"0.3.2": "2016-11-16T03:28:05.704Z",
		"created": "2016-11-16T02:57:59.645Z",
		"modified": "2018-01-31T02:19:32.468Z",
		"0.3.0": "2016-11-16T02:57:59.645Z"
	},
	"dist-tags": {
		"latest": "0.3.3"
	},
	"_uplinks": {
		"npmjs": {
			"fetched": 1547749349629
		}
	},
	"_distfiles": {
		"lru_map-0.3.3.tgz": {
			"url": "https://repo.dev.wixpress.com/artifactory/api/npm/npm-repos/lru_map/-/lru_map-0.3.3.tgz",
			"sha": "b5c8351b9464cbd750335a79650a0ec0e56118dd"
		},
		"lru_map-0.3.1.tgz": {
			"url": "https://repo.dev.wixpress.com/artifactory/api/npm/npm-repos/lru_map/-/lru_map-0.3.1.tgz",
			"sha": "b96dcf6ffd06df30000fd63290a5b706a50d89e0"
		},
		"lru_map-0.3.2.tgz": {
			"url": "https://repo.dev.wixpress.com/artifactory/api/npm/npm-repos/lru_map/-/lru_map-0.3.2.tgz",
			"sha": "9b34996d5e77845647776ee670edfb8857e24368"
		},
		"lru_map-0.3.0.tgz": {
			"url": "https://repo.dev.wixpress.com/artifactory/api/npm/npm-repos/lru_map/-/lru_map-0.3.0.tgz",
			"sha": "e73bb0220706c64e22c83c9982283f8fb9799236"
		}
	},
	"_attachments": {},
	"_rev": "5-93b046738a09c004",
	"readme": "# Least Recently Used (LRU) cache algorithm\n\nA finite key-value map using the [Least Recently Used (LRU)](http://en.wikipedia.org/wiki/Cache_algorithms#Least_Recently_Used) algorithm, where the most recently-used items are \"kept alive\" while older, less-recently used items are evicted to make room for newer items.\n\nUseful when you want to limit use of memory to only hold commonly-used things.\n\n[![Build status](https://travis-ci.org/rsms/js-lru.svg?branch=master)](https://travis-ci.org/rsms/js-lru)\n\n## Terminology & design\n\n- Based on a doubly-linked list for low complexity random shuffling of entries.\n\n- The cache object iself has a \"head\" (least recently used entry) and a\n  \"tail\" (most recently used entry).\n\n- The \"oldest\" and \"newest\" are list entries -- an entry might have a \"newer\" and\n  an \"older\" entry (doubly-linked, \"older\" being close to \"head\" and \"newer\"\n  being closer to \"tail\").\n\n- Key lookup is done through a key-entry mapping native object, which on most \n  platforms mean `O(1)` complexity. This comes at a very low memory cost  (for \n  storing two extra pointers for each entry).\n\nFancy ASCII art illustration of the general design:\n\n```txt\n           entry             entry             entry             entry        \n           ______            ______            ______            ______       \n          | head |.newer => |      |.newer => |      |.newer => | tail |      \n.oldest = |  A   |          |  B   |          |  C   |          |  D   | = .newest\n          |______| <= older.|______| <= older.|______| <= older.|______|      \n                                                                             \n       removed  <--  <--  <--  <--  <--  <--  <--  <--  <--  <--  <--  added\n```\n\n## Example\n\n```js\nlet c = new LRUMap(3)\nc.set('adam',   29)\nc.set('john',   26)\nc.set('angela', 24)\nc.toString()        // -> \"adam:29 < john:26 < angela:24\"\nc.get('john')       // -> 26\n\n// Now 'john' is the most recently used entry, since we just requested it\nc.toString()        // -> \"adam:29 < angela:24 < john:26\"\nc.set('zorro', 141) // -> {key:adam, value:29}\n\n// Because we only have room for 3 entries, adding 'zorro' caused 'adam'\n// to be removed in order to make room for the new entry\nc.toString()        // -> \"angela:24 < john:26 < zorro:141\"\n```\n\n# Usage\n\n**Recommended:** Copy the code in lru.js or copy the lru.js and lru.d.ts files into your source directory. For minimal functionality, you only need the lines up until the comment that says \"Following code is optional\".\n\n**Using NPM:** [`yarn add lru_map`](https://www.npmjs.com/package/lru_map) (note that because NPM is one large flat namespace, you need to import the module as \"lru_map\" rather than simply \"lru\".)\n\n**Using AMD:** An [AMD](https://github.com/amdjs/amdjs-api/blob/master/AMD.md#amd) module loader like [`amdld`](https://github.com/rsms/js-amdld) can be used to load this module as well. There should be nothing to configure.\n\n**Testing**:\n\n- Run tests with `npm test`\n- Run benchmarks with `npm run benchmark`\n\n**ES compatibility:** This implementation is compatible with modern JavaScript environments and depend on the following features not found in ES5:\n\n- `const` and `let` keywords\n- `Symbol` including `Symbol.iterator`\n- `Map`\n\n> Note: If you need ES5 compatibility e.g. to use with older browsers, [please use version 2](https://github.com/rsms/js-lru/tree/v2) which has a slightly less feature-full API but is well-tested and about as fast as this implementation.\n\n**Using with TypeScript**\n\nThis module comes with complete typing coverage for use with TypeScript. If you copied the code or files rather than using a module loader, make sure to include `lru.d.ts` into the same location where you put `lru.js`.\n\n```ts\nimport {LRUMap} from './lru'\n// import {LRUMap} from 'lru'     // when using via AMD\n// import {LRUMap} from 'lru_map' // when using from NPM\nconsole.log('LRUMap:', LRUMap)\n```\n\n# API\n\nThe API imitates that of [`Map`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map), which means that in most cases you can use `LRUMap` as a drop-in replacement for `Map`.\n\n```ts\nexport class LRUMap<K,V> {\n  // Construct a new cache object which will hold up to limit entries.\n  // When the size == limit, a `put` operation will evict the oldest entry.\n  //\n  // If `entries` is provided, all entries are added to the new map.\n  // `entries` should be an Array or other iterable object whose elements are\n  // key-value pairs (2-element Arrays). Each key-value pair is added to the new Map.\n  // null is treated as undefined.\n  constructor(limit :number, entries? :Iterable<[K,V]>);\n\n  // Convenience constructor equivalent to `new LRUMap(count(entries), entries)`\n  constructor(entries :Iterable<[K,V]>);\n\n  // Current number of items\n  size :number;\n\n  // Maximum number of items this map can hold\n  limit :number;\n\n  // Least recently-used entry. Invalidated when map is modified.\n  oldest :Entry<K,V>;\n\n  // Most recently-used entry. Invalidated when map is modified.\n  newest :Entry<K,V>;\n\n  // Replace all values in this map with key-value pairs (2-element Arrays) from\n  // provided iterable.\n  assign(entries :Iterable<[K,V]>) : void;\n\n  // Put <value> into the cache associated with <key>. Replaces any existing entry\n  // with the same key. Returns `this`.\n  set(key :K, value :V) : LRUMap<K,V>;\n\n  // Purge the least recently used (oldest) entry from the cache.\n  // Returns the removed entry or undefined if the cache was empty.\n  shift() : [K,V] | undefined;\n\n  // Get and register recent use of <key>.\n  // Returns the value associated with <key> or undefined if not in cache.\n  get(key :K) : V | undefined;\n\n  // Check if there's a value for key in the cache without registering recent use.\n  has(key :K) : boolean;\n\n  // Access value for <key> without registering recent use. Useful if you do not\n  // want to chage the state of the map, but only \"peek\" at it.\n  // Returns the value associated with <key> if found, or undefined if not found.\n  find(key :K) : V | undefined;\n\n  // Remove entry <key> from cache and return its value.\n  // Returns the removed value, or undefined if not found.\n  delete(key :K) : V | undefined;\n\n  // Removes all entries\n  clear() : void;\n\n  // Returns an iterator over all keys, starting with the oldest.\n  keys() : Iterator<K>;\n\n  // Returns an iterator over all values, starting with the oldest.\n  values() : Iterator<V>;\n\n  // Returns an iterator over all entries, starting with the oldest.\n  entries() : Iterator<[K,V]>;\n\n  // Returns an iterator over all entries, starting with the oldest.\n  [Symbol.iterator]() : Iterator<[K,V]>;\n\n  // Call `fun` for each entry, starting with the oldest entry.\n  forEach(fun :(value :V, key :K, m :LRUMap<K,V>)=>void, thisArg? :any) : void;\n\n  // Returns an object suitable for JSON encoding\n  toJSON() : Array<{key :K, value :V}>;\n\n  // Returns a human-readable text representation\n  toString() : string;\n}\n\n// An entry holds the key and value, and pointers to any older and newer entries.\n// Entries might hold references to adjacent entries in the internal linked-list.\n// Therefore you should never store or modify Entry objects. Instead, reference the\n// key and value of an entry when needed.\ninterface Entry<K,V> {\n  key   :K;\n  value :V;\n}\n```\n\nIf you need to perform any form of finalization of items as they are evicted from the cache, wrapping the `shift` method is a good way to do it:\n\n```js\nlet c = new LRUMap(123);\nc.shift = function() {\n  let entry = LRUMap.prototype.shift.call(this);\n  doSomethingWith(entry);\n  return entry;\n}\n```\n\nThe internals calls `shift` as entries need to be evicted, so this method is guaranteed to be called for any item that's removed from the cache. The returned entry must not include any strong references to other entries. See note in the documentation of `LRUMap.prototype.set()`.\n\n\n# MIT license\n\nCopyright (c) 2010-2016 Rasmus Andersson <https://rsms.me/>\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE."
}